\documentclass[titlepage, 12pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amssymb}

% Paragraph formatting
\setlength{\parindent}{0pt}
\usepackage{setspace}
\onehalfspacing
% Margin
\usepackage[margin=1in]{geometry}

% Redefine emph to also bold text
\let\emph\relax
\DeclareTextFontCommand{\emph}{\bfseries\em}

% Some chars
\newcommand\BS{\char`\\}
\newcommand\HASH{\char`\#}
\newcommand\SCMCAR{\BS\HASH}

% Title formatting
\usepackage{titlesec}
\titleformat*{\section}{\large\bfseries}
\renewcommand\thesection{\arabic{section}.}
\titleformat*{\subsection}{\normalsize\bfseries}
\renewcommand\thesubsection{(\alph{subsection})}

% Doc info
\title{IFT2035 A2016 \\ TP2 Rapport}
\author{Alizée Gagnon \and Guillaume Noël-Martel}

\begin{document}

\maketitle

\section{Fonctionnement général du programme}

On a défini une liste de couples de fonctions des tests et des manières d'opérer. Lorsqu'on cherche dans cette liste de couples, on applique toujours la première fonction sur le token. Si le test réussit, la recherche se conclut et on applique la deuxième fonction du couple sur \emph{state} et \emph{token}. Cette fonction génère le nouvel état.\\
L'utilisateur écrit une expression mathématique qui est envoyée à la fonction \emph{traiter}, avec un dictionnaire contenant les variables initialisées. Nous utilisons la fonction tokenize pour transformer l'expression en une liste des termes qui y sont présents, sans les espaces. Chacun des \emph{tokens} est une liste qui contient les caractères du terme qu'il représente: par exemple, \emph{­123 2 +} devient \emph{((\SCMCAR1 \SCMCAR2 \SCMCAR3) (\SCMCAR2) (\SCMCAR+))}. On veut ensuite traiter cette expression en utilisant une pile, comme pour le TP1. On veut passer à travers la liste de tokens et faire les bonnes opérations; ajouter les nombres, gérer les variables, etc. Pour passer à travers la liste, on utilisera \emph{foldl}. En effet, on va calculer l'expression comme les transformations successives des tokens sur la pile et le dictionnaire. On crée \emph{state}, une liste commençant avec la pile (vide au début de chaque analyse de ligne) suivie des éléments du dictionnaire. La fonction utilisée avec \emph{foldl}, \emph{process-token} fait une recherche avec continuation sur les différentes manières d'opérer sur un token pour trouver celle à utiliser.\\
\\
Les fonctions qui appliquent les opérations des tokens sont \emph{add-token-to-pile}, \emph{process-operator}, \emph{process-set} et \emph{process-ref}. Elles gèrent respectivement les nombres, les opérateurs (* + -), les assignations de variables et les références à des variables. Chaque opération recrée le nouvel état après l'application de celle-ci, ainsi:

\begin{description}

\item La fonction \emph{add-token-to-pile} ajoute le \emph{token}, identifié comme étant un nombre, à la pile.

\item La fonction \emph{process-operator} détermine les deux éléments du haut de la pile, la pile sans ces deux éléments et ajoute le résultat de l'opérateur correspondant au \emph{token} sur le dessus de la pile sans les opérandes. La fonction pour opérer est déterminée en faisant une recherche sur la liste associative des \emph{tokens} correspondants aux fonctions.

\item La fonction \emph{process-set} part du dictionnaire ne contenant que la nouvelle entrée (le \emph{token} associé au nombre sur le dessus de la pile) et opère un \emph{foldl} passant à travers l'ancien dictionnaire. On ajoute les entrées de celui-ci au nouveau; si une des entrées est correspondante au \emph{token}, alors on l'ignore (puisque l'entrée a été redéfinie).

\item La fonction \emph{process-ref} est simplement l'ajout à la pile du résultat de la recherche à l'aide de \emph{find-cont} (une recherche avec continuation) du \emph{token} sur le dictionnaire.

\end{description}

\section{Résolution de problèmes de programmation}

\subsection{Analyse syntaxique d'une expression et\\traitement d'une expression de longueur quelconque}

\subsection{Calcul de l'expression}

\subsection{Affectation aux variables}

\subsection{Affichage des résultats et des erreurs}

Comme le \emph{repl} s'attend à recevoir une liste contenant une chaîne de caractères suivit du dictionnaire, on a simplement à reconstruire une telle structure une fois que le traitement de l'expression est complétée. Donc pour afficher les résultats, on dépile simplement le premier nombre de la pile et on l'attache devant le nouveau dictionnaire avec \emph{cons}. De la même façon, pour afficher le message d'erreur, on attache devant l'ancien dictionnaire le message à afficher.

\subsection{Traitement des erreurs}

Le traitement des erreurs est simple. On applique le principe du try...catch en utilisant les outils du langage. Notre méthode la plus englobante, \emph{traiter}, utilise la fonction \emph{with-exception-catcher}, qui prend deux fonctions; la fonction de \emph{catch} et de \emph{try}. Elle surveille l'exécution du \emph{try} et si une exception est lancée elle roule la fonction de \emph{catch}. Dans ce cas ci, chaque exception qu'on lance au cours de l'exécution donne un message d'erreur d'écrivant le problème. Dans le \emph{catch}, on ajoute ce message devant le dictionnaire pour qu'il soit imprimé à la place de la pile.\\
Nos définition de fonctions avec continuation qui peuvent échouer définissent deux continuations différentes; en cas de succès et en cas d'échecs. Dans le cas de \emph{find-cont} on définit l'échec comme une recherche infructueuse. Ces fonctions d'échec lancent le message d'erreur approprié au contexte avec \emph{raise}. Similairement, dans le cas de dépiler, par exemple quand vient temps d'effectuer une opération mathématique sur deux nombres ou d'attribuer une valeur à une variable, l'échec est définit comme une manque d'arguments.\\
On lance aussi une exception dans Traiter au moment de renvoyer la pile et le dictionnaire. On vérifie si la pile contient plus qu'un élément. Dans ce cas, on a une erreur de syntaxe car on a donné trop d'arguments à l'expression.

\section{Comparaison de notre expérience au TP1}

Il y a divers aspects de Scheme qui ont grandement simplifié la programmation vis-à-vis de C. Au final notre programme Scheme fait environs 200 lignes et notre programme C, un peu plus de 600 lignes.\\
Une des parties les plus volumineuses de notre programme C est la gestion des nombres de taille arbitraires. Comme C ne propose que des nombres de taille fixe, environs 30\% de notre programme est uniquement les définitions de nombres et de leur opération. En Scheme, rien de cela n'est nécessaire.\\
Une autre partie que Scheme gère automatiquement est la gestion de la mémoire; comme en C il faut allouer et désallouer les blocs de mémoires, une partie significative de notre code était dédiée à gérer cela et les erreurs reliées à ces problèmes. Ceci n'est tout simplement pas un problème pour Scheme.\\
Finalement, une autre partie de C est relativement déficiente est la gestion des erreurs. Le langage ne propose pas de constructions pour lancer et attraper des erreurs et que la gestion de la mémoire impose de libérer correctement la mémoire lors des arrêts à mi-chemin des fonctions. On a donc que la plupart des fonctions sont complexifiées par des vérifications d'erreurs globales (l'alternative aurait été que les fonctions retourne d'une manière ou d'une autre les erreurs) et la libération partielle ou complète de bouts de mémoire.\\
\\
Les différences précédentes sont toutes attribuables au fait que Scheme est de plus haut niveau que C; une implémentation de la calculatrice en Python ou en Javascript aurait eu des bénéfices similaires. Une autre différence majeure est que notre code C est écrit de manière foncièrement impérative (il est relativement dur d'écrire du code C dans un style fonctionnel) alors que notre Scheme s'est limité à la partie fonctionnelle.\\
Ainsi, il est possible d'exprimer la totalité du programme comme une série de transformations pures sur une expression et un dictionnaire.\\
On peut donc décomposer le but du programme en parties plus petites jusqu'à ce qu'on puisse exprimer des fonctions simples et évidentes. Si une expression postfixe est une série d'opérations sur une pile, avec cette expression étant une suite de termes qui n'ont besoin que de la pile et du dictionnaire comme contexte pour générer le nouveau contexte, on peut donc raisonner comme qui suit:\\
À partir d'une liste de caractères représentant l'expression, si on veut opérer il faut d'abord transformer cette liste en liste de \emph{tokens}; il faut \emph{tokenizer}.\\
Pour pouvoir opérer des transformations sur les \emph{token}, il faut pouvoir identifier l'opération correspondante à chaque token.\\
Pour identifier et appliquer l'opération, il faut construire chacune des opérations de la calculatrice.\\
Pour chacune des opérations, il faut un test qui dit simplement si on peut opérer ou non et il faut une fonction qui effectue la transformation du token sur le contexte.\\
Et ainsi de suite: Éventuellement on arrive à des fonctions simples comme  \emph{number?} et \emph{add-to-pile}.\\
\\
Les opérations définies sur des ensembles du programme sont quasiment toutes définies sous forme récursive itérative: Principalement, si une opération se porte bien à être définie à l'aide d'un \emph{foldl} c'est ce qui est utilisé. Par exemple et comme mentionné précédemment, le traitement de l'expression est exprimé comme un \emph{foldl} sur les \emph{tokens} avec chaque étape étant l'application de la bonne opération. Sinon, une autre exemple typique est la recherche; que ce soit sur le dictionnaire pour trouver les variables ou sur les types d'opérations pour un \emph{token} quelconque.\\
\\
En ce qui concerne les continuations, elles sont utilisées principalement afin de marquer des types de résultats différents; pour \emph{find} on définit un argument de continuation en cas de succès (\emph{cont}) et un argument de continuation en cas d'échec (\emph{fail}). Il est alors assez simple de définir diverses manières de gérer des résultats sans avoir à vérifier la nature de l'argument. Dans le cas de \emph{split-at}, qui est utilisé pour définir \emph{depile}, la continuation nous permet de définir un retour de plusieurs arguments de la fonction: Soit les éléments de tête, pour lesquelles que l'argument accepte et les éléments de queue, qui sont ceux à partir du premier élément refusé. Sur la fonction \emph{depile} on a alors les éléments dépilés et le reste de la pile.

\end{document}